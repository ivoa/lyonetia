// Note: in the actual PEG definition comments start with #
// =========================== Configurables for deployers

udf_prefix <-
	'ivo_';  // additional prefixes to be added here

// ============================ The Grammar's root symbol

query_specification <-
	with_clause? _
	query_expression _ EOF;

// ============================ Top level query parts

with_clause <-
	'WITH' _ with_query
		_ (','_ with_query )*;

with_query <-
	identifier __ as
	_ '(' _ query_expression _ ')';

// Rewriting query_expression to have set operator syntax like
// postgres.
query_expression <-
	select_query
	(_ set_operator
	_ set_query_expression)*;

set_operator <-
	('EXCEPT' / 'INTERSECT' / 'UNION') _a
	(__ 'ALL' _a)?;

set_query_expression <-
	query_expression
	/ '(' _ query_expression _ ')';

// The SELECT clause itself

select_query <-
	_ 'SELECT'
	(__ set_quantifier)?
	(_ set_limit)?
	_ select_list
	_ table_expression;

set_quantifier <-
	('DISTINCT' / 'ALL') _a;

set_limit <-
	'TOP' __ unsigned_integer;

// ================================= Select lists and their items
select_list	<-
	'*'
	/ select_sublist (_ ',' _ select_sublist)*;

select_sublist <-
	table_name _ '.' _ '*'
	/ derived_column;

derived_column <-
	value_expression _ as_clause?;

// Table expressions (FROM clause: tables, join, etc.)

table_expression <-
	from_clause
	(_ where_clause)?
	(_ group_by_clause)?
	(_ order_by_clause)?
	(_ offset_clause)?;

from_clause <-
	'FROM' __ from_list;

from_list <-
	table_reference
	(_ ',' _ table_reference)*;

// joining correlation_specification and as_clause
as_clause <-
	as? _ identifier;

table_reference <-
	joined_table
	/ table_name _ as_clause?
	/ subquery _ as_clause;

// JOIN clause and related elements

joined_table <-
	qualified_join
	/ sub_join;

sub_join <-
	'(' _ joined_table _ ')';

join_opener <-
	sub_join
	/ table_name _ as_clause?
	/ subquery _ as_clause;

qualified_join <-
	join_opener _ join_clause;

subquery <-
	'(' _ query_expression _ ')';

join_clause <-
	join_method? _ join _
	table_reference (_ join_specification)?
	(_ (sub_join / join_clause))*;

join_type <-
	('INNER'
	/ (outer_join_type _)? 'OUTER') _a;

outer_join_type <-
	('LEFT' / 'RIGHT' / 'FULL') _a;

join_method	<-
	natural? _ (join_type)?;

join_specification	<-
	join_condition
	/ named_columns_join;

join_condition <-
	on _ search_condition;

named_columns_join <-
	'USING' _ '('
	_ identifier (_ ',' _ identifier)*
	_ ')';

// WHERE clause and related elements

where_clause <-
	where _ search_condition;

search_condition <-
	boolean_term _ (or _ boolean_term)*;

boolean_term <-
	boolean_factor _ (and _ boolean_factor)*;

predicate <-
	comparison_predicate
	/ between_predicate
	/ in_predicate
	/ like_predicate
	/ null_predicate
	/ exists_predicate;

boolean_factor <-
	not? _ boolean_primary;

boolean_primary <-
	'(' search_condition ')'
	/ predicate;

null_predicate <-
	column_reference
	_ 'IS' _ not?
	_ ('TRUE' / 'FALSE' / 'UNKNOWN' / 'NULL');

comparison_predicate <-
	value_expression _ comp_op _ value_expression;

like_predicate <-
	character_value_expression
	_ not? _ ('ILIKE' / 'LIKE')
	_ character_value_expression;

comp_op <-
	'=' / '!=' / '<=' / '>=' / '>' / '<';

between_predicate <-
	value_expression
	_ not? _ between
	_ value_expression _ and _ value_expression;

in_predicate <-
	value_expression
	_ not? _ in
	_ in_predicate_value;

in_predicate_value <-
	identifier
	/ '(' value_expression (_ ',' _  value_expression)* ')'
	/ '(' query_expression ')';

exists_predicate <-
	not? _ 'EXISTS' __ subquery;

order_by_clause <-
	'ORDER' __ 'BY' __ sort_specification_list;

sort_specification_list <-
	sort_specification
	(_ ',' _ sort_specification)*;

sort_specification <-
	sort_key (_ ordering_specification)?;

sort_key <-
	identifier
	/ unsigned_integer;

ordering_specification <-
	'ASC'
	/ 'DESC';

// HAVING clause depends on GROUP BY
group_by_clause <-
	'GROUP' __ 'BY' __ group_by_term_list
	(__ having_clause)?;

group_by_term_list <-
	identifier (_ ',' _ identifier)*;

having_clause <-
	'HAVING' __
	('(' _  search_condition _ ')'
	/ _ search_condition );

offset_clause <-
	'OFFSET' __ unsigned_integer;

// Identifiers (<schema>.<table>.<field>), numerical / geometrical
// / string expressions and functions

table_name <-
	identifier (_ '.' _ identifier)? (_ '.' _ identifier)?;

// we don't re-use table_name here since PEG uses greedy matching
// and thus would parse x.a all as a table name.  Thus, for
// column_reference we simply allow 1..4 identifiers.
column_reference <-
	(identifier _ '.' _)? (identifier _ '.' _)? (identifier _ '.' _)? identifier;

identifier <-
	(regular_identifier / delimited_identifier);

delimited_identifier <-
	'"' ('""' / r'[^"]')+ '"';

regular_identifier <-
	(!(keyword) letter (letter / digit / '_')*);

character_string_literal <-
	("'" ("''" / r"[^']")* "'" (Space+ comment _)*)+;

fold_function <-
	('UPPER' / 'LOWER') _
	'(' _ character_value_expression _ ')';

string_value_function <-
	string_geometry_function
	/ fold_function
	/ user_defined_function;

character_primary <-
	character_string_literal
	/ string_value_function
	/ value_expression_primary;

concatenation <-
	character_primary
	_ '||'
	_ character_value_expression;

// concatenation2 <-
//	character_primary (_ '||' _ concatenation2)*;

geometry_function <-
	geometry_value_function
	/ non_predicate_geometry_function
	/ predicate_geometry_function
	/ region
	/ extract_coord_sys;

bitwise_op <-
	'&' / '|' / '^';

bitwise_expression <-
	'~' numeric_value_expression
	/ numeric_value_expression
	_ bitwise_op
	_ numeric_value_expression;

string_value_expression <-
	character_value_expression;

character_value_expression <-
	concatenation
	/ column_reference
	/ character_primary;

geometry_value_function <-
	box
	/ centroid
	/ circle
	/ point
	/ polygon
	/ region
	/ user_defined_function;

coordinates <-
	numeric_value_expression _ ','
	_ numeric_value_expression;

box <-
	'BOX' _ '('
	( _ character_string_literal ',')?
	_ coordinates _ ','
	_ numeric_value_expression _ ','
	_ numeric_value_expression _ ')';

centroid <-
	'CENTROID' _ '('
	_ geometry_value_expression _ ')';

circle <-
	'CIRCLE' _ '('
	_ string_value_expression _ ','
	_ coordinates _ ','
	_ numeric_value_expression _ ')';

polygon <-
	'POLYGON' _ '('
	_ string_value_expression _ ','
	_ coordinates _ ','
	_ coordinates _
	(_ ',' _ coordinates)* _ ')';

non_predicate_geometry_function <-
	area
	/ coord1
	/ coord2
	/ distance;

area <-
	'AREA' _ '('
	_ geometry_value_expression
	_ ')';

coord1 <-
	'COORD1' _ '('
	_ coord_value
	_ ')';

coord2 <-
	'COORD2' _ '('
	_ coord_value
	_ ')';

coord_value <-
	point
	/ column_reference;

distance <-
	'DISTANCE' _ '('
	_ coord_value _ ','
	_ coord_value _ ')';

predicate_geometry_function <-
	contains
	/ intersects;

contains <-
	'CONTAINS' _ '('
	_ geometry_value_expression _ ','
	_ geometry_value_expression _ ')';

intersects <-
	'INTERSECTS' _ '('
	_ geometry_value_expression _ ','
	_ geometry_value_expression _ ')';

region <-
	'REGION' _ '(' _  string_value_expression _ ')';

extract_coord_sys <-
	'COORDSYS' _ '(' _ geometry_value_expression _ ')';

string_geometry_function <-
	extract_coord_sys
	/ user_defined_function;

math_function <-
	(onetwo_param_math '('
	_ numeric_value_expression (_ ',' _ signed_integer)?
	_ ')')
	/ (two_param_math '('
	_  numeric_value_expression _ ','
	_ numeric_value_expression _')')
	/ (one_param_math '(' _ numeric_value_expression _ ')')
	/ rand_function
	/ (no_param_math '()');

trig_function <-
	(two_param_trig '('
	_  numeric_value_expression _ ','
	_ numeric_value_expression _')')
	/ (one_param_trig '('
	_ numeric_value_expression _ ')');

// No params
no_param_math <-
	'PI';

// One param
one_param_trig <-
	'ACOS' / 'ASIN' / 'ATAN' / 'COS' /
	'COT' / 'SIN' / 'TAN';

one_param_math <-
	'ABS' / 'CEILING' / 'DEGREES' / 'EXP' /
	'FLOOR' / 'LOG10' / 'LOG' / 'RADIANS' /
	'SQRT';

// Two param
two_param_math <-
	'MOD' / 'POWER';

two_param_trig <-
	'ATAN2';

onetwo_param_math <-
	'ROUND' / 'TRUNCATE';

rand_function <-
	'RAND' _ '(' (_ numeric_value_expression _)? ')';

string_function <-
	string_func_name '(' _ value_expression _ ')';

string_func_name <-
	'LOWER';

set_function_specification <-
	'COUNT' _ '(' ('*' /
	(set_quantifier __)? identifier) ')'
	/ general_set_function;

set_function_type <-
	'AVG' / 'MAX' / 'MIN' / 'SUM';

general_set_function <-
	set_function_type '('
	set_quantifier? numeric_value_expression ')';

point <-
	'POINT' _ '('
	_ (string_value_expression / 'NULL')
	_ ',' _ coordinates _ ')';

numeric_value_expression <-
	term (_ ('+' / '-') _ numeric_value_expression)*;

term <-
	factor (_ ('*' / '/') _ term)*;

factor <-
	('+' / '-')? numeric_primary;

numeric_value_function <-
	math_function
	/ trig_function
	/ numeric_geometry_function
	/ user_defined_function;

numeric_geometry_function <-
	predicate_geometry_function
	/ non_predicate_geometry_function;

udf_name <-
	udf_prefix regular_identifier;

user_defined_function <-
	udf_name '('
	(_ value_expression (_ ',' _ value_expression)* _)?
	')';

numeric_primary	<-
	value_expression_primary
	/ numeric_value_function;

// We need to seriously re-write value_expression because PEG
// doesn't have an actual longest-match operator.  Thus, we
// cannot decide on the type of the first operand.
// TODO: see how much this overproduces wrt the original grammar:
// (e.g., is '5'+4+3 ok by the BNF?  PG accepts that, btw)
value_expression_first_operand <- 
	user_defined_function
	/ column_reference
	/ string_expression_operand
	/ numeric_expression_operand;

value_expression <- ( 
		value_expression_first_operand _ (
			string_expression_rest
			/ numeric_expression_rest)?
	/ geometry_value_expression);

// TODO: value_expression_primary (as in the BNF) is unnecessarily wide
// here ("CENTROID(3)")
geometry_value_expression <-
	value_expression_primary
	/ geometry_value_function;

value_expression_primary <-
	unsigned_literal
	/ column_reference
	/ set_function_specification
	/ '(' value_expression ')';

string_expression <-
	string_expression_operand (_ string_expression_rest)*;

string_expression_operand <-
	character_value_expression;

string_expression_rest <-
	'||' _ string_expression_operand;

numeric_expression <-
	numeric_expression_operand (_ numeric_expression_rest)*;

numeric_expression_operand <-
	numeric_value_expression;

numeric_expression_rest <-
	('+' / '-' / '*' / '/') _ numeric_expression_operand;

approximate_numeric_literal <-
	exact_numeric_literal 'E'
	signed_integer;

exact_numeric_literal	<-
	(unsigned_integer '.')* unsigned_integer;

signed_integer <-
	('+' / '-')? unsigned_integer;

// TODO: We should take out character_string_literal here, MD thinks --
// what sort of use case did people have in mind here?
// "POINT('ICRS',X,'SY')"

unsigned_literal <-
	unsigned_numeric_literal
	/ character_string_literal;

unsigned_numeric_literal <-
	approximate_numeric_literal
	/ exact_numeric_literal;

numeric_primary <-
	value_expression_primary
	/ numeric_value_function;

unsigned_integer <-
	digit+;

unsigned_hexadecimal <-
	'0x' hex_digit+;

digit <-
	r'[0-9]';

hex_digit <-
	r'[0-9A-F]';

letter <-
	r'[a-zA-Z]';

// Reserved words

as <-
	'AS' _a;

on <-
	'ON' _a;

in <-
	'IN' _a;

join <-
	'JOIN' _a;

natural <-
	'NATURAL' _a;

between <-
	'BETWEEN' _a;

and <-
	'AND' _a;

or <-
	'OR' _a;

not <-
	'NOT' _a;

where <-
	'WHERE' _a;

keyword <-
	ADQL_reserved_word / SQL_reserved_word;

// Caution: If one reserved word is a prefix of another, the longer
// word needs to come first by PEG longest-match wins rules.
ADQL_reserved_word <-
	('ABS' / 'ACOS' / 'AREA' / 'ASIN' / 'ATAN2'
	/ 'ATAN' / 'BIT_AND' / 'BIT_NOT' / 'BIT_OR'
	/ 'BIT_XOR' / 'BOX' / 'CEILING' / 'CENTROID'
	/ 'CIRCLE' / 'CONTAINS' / 'COORD1' / 'COORD2'
	/ 'COORDSYS' / 'COS' / 'DEGREES' / 'DISTANCE'
	/ 'EXP' / 'FLOOR' / 'ILIKE' / 'INTERSECTS'
	/ 'IN_UNIT' / 'LOG10' / 'LOG' / 'MOD'
	/ 'PI' / 'POINT' / 'POLYGON' / 'POWER'
	/ 'RADIANS' / 'REGION' / 'RAND' / 'ROUND'
	/ 'SIN' / 'SQRT' / 'TOP' / 'TAN' / 'TRUNCATE') _a;

SQL_reserved_word <-
	('ABSOLUTE' / 'ACTION' / 'ADD' / 'ALLOCATE '/ 'ALL'
	/ 'ALTER' / and / 'ANY' / 'ARE' / as
	/ 'ASC' / 'ASSERTION' / 'AT' / 'AUTHORISATION'
	/ 'AVG' / 'BEGIN' / between / 'BIT_LENGTH' / 'BIT' / 'BOTH'
	/ 'BY' / 'CASCADE' / 'CASCADED' / 'CASE' / 'CAST'
	/ 'CATALOG' / 'CHARACTER' / 'CHAR_LENGTH' / 'CHAR'
	/ 'CHARACTER_LENGTH' / 'CHECK' / 'CLOSE' / 'COALESCE'
	/ 'COLLATE' / 'COLLATION' / 'COLUMN' / 'COMMIT'
	/ 'CONNECT' / 'CONNECTION' / 'CONSTRAINT'
	/ 'CONSTRAINTS' / 'CONTINUE' / 'CONVERT'
	/ 'CORRESPONDING' / 'COUNT' / 'CREATE' / 'CROSS'
	/ 'CURRENT_DATE' / 'CURRENT_TIME'
	/ 'CURRENT_TIMESTAMP' / 'CURRENT_USER' / 'CURRENT' / 'CURSOR'
	/ 'DATE' / 'DAY' / 'DEALLOCATE' / 'DECIMAL'
	/ 'DECLARE' / 'DEFAULT' / 'DEFERRABLE' / 'DEFERRED'
	/ 'DELETE' / 'DESCRIBE' / 'DESCRIPTOR' / 'DESC'
	/ 'DIAGNOSTICS' / 'DISCONNECT' / 'DISTINCT' / 'DOMAIN'
	/ 'DOUBLE' / 'DROP' / 'ELSE' / 'END-EXEC' / 'END'
	/ 'ESCAPE' / 'EXCEPT' / 'EXCEPTION'
	/ 'EXECUTE' / 'EXEC' / 'EXISTS' / 'EXTERNAL' / 'EXTRACT'
	/ 'FALSE' / 'FETCH' / 'FIRST' / 'FLOAT' / 'FOR'
	/ 'FOREIGN' / 'FOUND' / 'FROM' / 'FULL' / 'GET'
	/ 'GLOBAL' / 'GOTO' / 'GO' / 'GRANT' / 'GROUP'
	/ 'HAVING' / 'HOUR' / 'IDENTITY' / 'IMMEDIATE'
	/ 'INDICATOR' / 'INITIALLY' / 'INNER'
	/ 'INPUT' / 'INSENSITIVE' / 'INSERT'
	/ 'INTEGER' / 'INTERSECT' / 'INTERVAL' / 'INTO' / 'INT' / 'IN'
	/ 'IS' / 'ISOLATION' / join / 'KEY' / 'LANGUAGE'
	/ 'LAST' / 'LEADING' / 'LEFT' / 'LEVEL'
	/ 'LIKE' / 'ILIKE' / 'LOCAL' / 'LOWER' / 'MATCH'
	/ 'MAX' / 'MIN' / 'MINUTE' / 'MODULE'
	/ 'MONTH' / 'NAMES' / 'NATIONAL' / natural
	/ 'NCHAR' / 'NEXT' / 'NO' / not / 'NULL'
	/ 'NULLIF'/ 'NUMERIC' / 'OCTET_LENGTH' / 'OFFSET'
	/ 'OF' / on / 'ONLY' / 'OPEN' / 'OPTION' / or
	/ 'ORDER' / 'OUTER' / 'OUTPUT' / 'OVERLAPS' / 'PAD'
	/ 'PARTIAL' / 'POSITION' / 'PRECISION' / 'PREPARE'
	/ 'PRESERVE' / 'PRIMARY' / 'PRIOR' / 'PRIVILEGES'
	/ 'PROCEDURE' / 'PUBLIC' / 'READ'
	/ 'REAL' / 'REFERENCES' / 'RELATIVE' / 'RESTRICT'
	/ 'REVOKE' / 'RIGHT' / 'ROLLBACK' / 'ROWS'
	/ 'SCHEMA' / 'SCROLL' / 'SECOND' / 'SELECT' / 'SECTION'
	/ 'SESSION_USER' / 'SET' / 'SIZE' / 'SMALLINT' / 'SOME'
	/ 'SPACE' / 'SQL' / 'SQLCODE' / 'SQLERROR' / 'SQLSTATE'
	/ 'SUBSTRING' / 'SUM' / 'SYSTEM_USER' / 'TABLE'
	/ 'TEMPORARY' / 'THEN' / 'TIMESTAMP'
	/ 'TIMEZONE_HOUR' / 'TIMEZONE_MINUTE' / 'TIME' / 'TO' / 'TRAILING'
	/ 'TRANSACTION'/ 'TRANSLATE' / 'TRANSLATION' / 'TRIM'
	/ 'TRUE' / 'UNION' / 'UNIQUE' / 'UNKNOWN' / 'UPDATE'
	/ 'UPPER' / 'USAGE' / 'USER' / 'USING' / 'VALUES'
	/ 'VALUE' / 'VARCHAR' / 'VARYING' / 'VIEW'
	/ 'WHENEVER' / 'WHEN' / where / 'WITH' / 'WORK' / 'WRITE'
	/ 'YEAR' / 'ZONE') _a;

// Auxiliary rules to handle things like whitespace and comments

ANY_CHAR <-
	letter / digit / ' ' / '\t' / ',' / ';' / '.';

comment	<-
	'--' r'[^\n\r]*';

_ <-
	(comment / Space / EOL)*;

__ <-
	(comment / Space / EOL)+;

_a <-
	!r'[A-Z0-9_]';

Space <-
	' '+ / '\t';

EOL <-
	'\r\n' / '\n' / '\r';
